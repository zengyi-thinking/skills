# 优化策略详细说明

本文档详细说明 Prompt Optimizer 使用的各种优化策略。

---

## 策略概览

| 策略 | 中文名 | 目标 | 适用场景 |
|-----|-------|------|---------|
| `clarity` | 清晰化 | 提高结构性和清晰度 | 简短、模糊的提示词 |
| `context` | 上下文增强 | 注入项目特定信息 | 技术性任务 |
| `examples` | 示例驱动 | 通过示例提高精确度 | 需要特定格式的任务 |
| `conciseness` | 精简化 | 去除冗余内容 | 冗长、啰嗦的提示词 |

---

## 1. Clarity (清晰化策略)

### 目标
将模糊的提示词转换为结构清晰、任务明确的高质量提示词。

### 操作步骤

#### 1.1 添加角色设定
根据技术栈和领域自动推断合适的角色：

**推断规则：**
- 后端技术栈 (Python/Django/FastAPI, Node.js/Express, Go, Java/Spring) → "资深后端开发工程师"
- 前端技术栈 (React, Vue, Angular, TypeScript) → "前端开发专家"
- DevOps 工具 (Docker, Kubernetes, CI/CD) → "DevOps 工程师"
- 数据工具 (Pandas, NumPy, PyTorch, TensorFlow) → "数据科学专家"
- 移动开发 (React Native, Flutter, Swift, Kotlin) → "移动应用开发工程师"

**示例：**
```
原始: "写个登录功能"
优化: "作为资深后端开发工程师，请实现用户登录功能..."
```

#### 1.2 添加任务结构
对于简短的提示词，添加任务分解框架：

```
**要求**：
1. 分析需求
2. 提供实现方案
3. 包含代码示例
4. 说明注意事项
```

#### 1.3 明确输出格式
添加输出格式要求，使结果更可预测：

```
**输出格式**：
- 代码实现
- 使用说明
- 测试用例
```

### 最佳使用场景

✅ 适合使用 clarity 策略的情况：
- 提示词少于 50 词
- 缺少明确的任务结构
- 没有指定输出格式
- 语气过于随意或不专业

❌ 不适合使用的情况：
- 已经有清晰结构的提示词
- 用户特别强调要保持简洁
- 提示词本身就是模板或格式化文档

### 效果示例

**输入：**
```
"帮我做个API"
```

**输出：**
```
作为资深后端开发工程师，请创建 RESTful API：

**要求**：
1. 分析需求和数据模型
2. 设计 API 端点结构
3. 实现完整的 CRUD 操作
4. 包含错误处理和验证
5. 添加 API 文档

**输出格式**：
- 代码实现
- 端点列表
- 使用示例
- 测试建议
```

---

## 2. Context Enhancement (上下文增强策略)

### 目标
从对话历史中提取技术信息并注入到提示词中，使AI能够生成更贴合项目的代码和解决方案。

### 操作步骤

#### 2.1 识别技术栈
从 Claude 提取的 context 中读取 `tech_stack` 字段：

```json
{
  "tech_stack": ["Python", "FastAPI", "React", "PostgreSQL"]
}
```

#### 2.2 注入技术栈信息
在提示词开头添加技术栈说明：

```
**技术栈**: Python, FastAPI, React, PostgreSQL

[原始提示词内容]
```

#### 2.3 添加领域特定要求
根据 `domain` 字段添加领域特定指导：

| Domain | 添加的要求 |
|--------|----------|
| `web_development` | 遵循 RESTful 最佳实践，确保代码可维护和可扩展 |
| `machine_learning` | 包含数据处理、模型训练和评估的完整流程 |
| `data_science` | 确保数据清洗、探索性分析和可视化的完整性 |
| `devops` | 遵循基础设施即代码原则，确保配置的可重复性 |
| `security` | 遵循安全最佳实践，考虑常见漏洞防护 |

#### 2.4 整合对话历史摘要
将 `history_summary` 中的相关上下文融入提示词：

```
原始: "添加分页功能"
上下文: "用户正在构建电商网站，使用 Django 和 PostgreSQL"
优化: "在 Django 电商网站项目中，为商品列表添加分页功能..."
```

### 最佳使用场景

✅ 适合使用 context 策略的情况：
- 提示词中未提及具体技术
- 项目使用了特定框架或库
- 需要与现有代码集成
- 有特定的业务领域要求

❌ 不适合使用的情况：
- 提示词已经详细说明技术栈
- 技术栈信息与当前任务无关
- 通用性任务（如算法设计）

### 效果示例

**输入：**
```
提示词: "实现用户认证"
Context: {
  "tech_stack": ["Python", "FastAPI", "JWT"],
  "domain": "web_development"
}
```

**输出：**
```
**技术栈**: Python, FastAPI, JWT

**领域要求**: 遵循 RESTful 最佳实践，确保代码可维护和可扩展

作为资深后端开发工程师，请实现用户认证功能...
```

---

## 3. Example-Driven (示例驱动策略)

### 目标
通过要求AI提供输入输出示例，提高结果的可预测性和可用性。

### 操作步骤

#### 3.1 添加示例要求
在提示词末尾添加：

```
**请包含使用示例和输出格式说明**
```

#### 3.2 针对不同类型任务的示例要求

**代码实现任务：**
```
**请包含**：
- 完整代码示例
- 调用示例
- 预期输出
```

**数据处理任务：**
```
**请包含**：
- 输入数据格式
- 处理步骤示例
- 输出数据格式
```

**API 设计任务：**
```
**请包含**：
- API 端点示例
- 请求/响应示例
- 错误处理示例
```

#### 3.3 格式化要求
添加格式说明使输出更结构化：

```
**输出格式**：
- Markdown 格式
- 代码块使用语法高亮
- 表格展示对比数据
```

### 最佳使用场景

✅ 适合使用 examples 策略的情况：
- 用户需要理解如何使用生成的代码
- 任务涉及特定的输入输出格式
- API 设计或接口定义
- 数据处理流程

❌ 不适合使用的情况：
- 用户明确说明不需要示例
- 简单直接的回答任务
- 概念性或理论性问题

### 效果示例

**输入：**
```
"实现一个缓存装饰器"
```

**输出：**
```
"实现一个Python缓存装饰器

**请包含**：
- 完整代码实现
- 使用示例（with/without 缓存）
- 性能对比示例
- 预期输出说明"
```

---

## 4. Conciseness (精简化策略)

### 目标
去除冗余内容，使提示词更简洁高效。

### 操作步骤

#### 4.1 去除重复表述
识别并删除语义重复的句子：

```
原始: "请帮我写一个函数。这个函数应该能够处理数据。需要处理数据的函数。"
精简: "请写一个处理数据的函数。"
```

#### 4.2 合并相似请求
将多个相关的简单请求合并：

```
原始: "添加错误处理。添加日志记录。添加单元测试。"
精简: "添加错误处理、日志记录和单元测试。"
```

#### 4.3 移除不必要的客套话
删除过度的礼貌用语：

```
原始: "麻烦您能不能请帮我看看这个代码，谢谢您了！"
精简: "请审查这段代码。"
```

#### 4.4 去除冗余的修饰词
删除不改变语义的形容词和副词：

```
原始: "创建一个非常强大、高效、快速的排序算法"
精简: "创建高效的排序算法"
```

### 最佳使用场景

✅ 适合使用 conciseness 策略的情况：
- 提示词超过 200 词
- 包含大量重复表述
- 用户偏好简洁风格（从历史学习）
- 需要减少 token 使用

❌ 不适合使用的情况：
- 用户偏好详细说明
- 复杂任务需要详细描述
- 礼貌用语是必要的场合

### 效果示例

**输入：**
```
"请帮我写一个Python函数。这个函数需要能够读取文件。函数应该处理大文件。
需要处理错误情况。请包含代码注释。"
```

**输出：**
```
"请编写一个Python函数来读取文件，要求：
1. 支持大文件处理
2. 包含错误处理
3. 添加代码注释"
```

---

## 策略组合

### 默认组合

| 模式 | 策略组合 | 适用情况 |
|-----|---------|---------|
| `minimal` | `clarity` | 简单优化，仅添加结构 |
| `moderate` | `clarity` + `context` | 平衡优化（默认） |
| `aggressive` | `clarity` + `context` + `examples` + `conciseness` | 全面优化 |

### 自定义组合

用户可以根据需求指定策略：

```bash
python scripts/optimize.py optimize \
  --prompt "..." \
  --context-json "..." \
  --strategies "clarity,examples"
```

### 策略冲突处理

当策略可能产生冲突时，优先级如下：
1. **conciseness** 最后执行（精简之前添加的内容）
2. **clarity** 首先执行（建立基础结构）
3. **context** 第二执行（添加上下文）
4. **examples** 第三执行（添加示例要求）

---

## 学习机制

### 策略权重调整

系统根据用户反馈动态调整策略权重：

```
strategy_weights: {
  "clarity": 0.8,      # 高权重
  "context": 0.7,      # 中高权重
  "examples": 0.6,     # 中等权重
  "conciseness": 0.3   # 低权重（用户不喜欢过度精简）
}
```

**权重调整规则：**
- 用户接受优化：相关策略权重 +0.1
- 用户拒绝优化：相关策略权重 -0.15
- 权重范围：0.0 ~ 1.0
- 权重 < 0.3 的策略会被过滤

### 编辑模式学习

从用户的编辑中学习偏好：

| 检测到的编辑模式 | 学习的偏好 |
|----------------|----------|
| 添加示例 | `likes_examples: true` |
- 删除大量内容 | `prefers_concise: true` |
| 扩展内容 | `prefers_detailed: true` |
| 添加技术细节 | `likes_technical_details: true` |
| 添加输出格式 | `likes_output_specs: true` |

---

## 故障排除

### 策略未生效

**问题：** 某个策略没有产生效果

**可能原因：**
1. 策略权重过低（被过滤）
2. 提示词已包含策略要添加的内容
3. 策略条件未满足

**解决方法：**
```bash
# 查看当前策略权重
python scripts/memory.py summary

# 强制使用特定策略
python scripts/optimize.py optimize \
  --strategies "clarity,context,examples" \
  --prompt "..." \
  --context-json "..."
```

### 过度优化

**问题：** 优化后的提示词过于冗长

**解决方法：**
```bash
# 使用 minimal 模式
--mode "minimal"

# 或排除某些策略
--strategies "clarity"
```

### 优化不足

**问题：** 优化后的提示词改善不明显

**解决方法：**
```bash
# 使用 aggressive 模式
--mode "aggressive"
```
